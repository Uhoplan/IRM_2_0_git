<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<svg height="31" width="80" xmlns:a="http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:atv="http://webmi.atvise.com/2007/svgext" version="1.2" xmlns="http://www.w3.org/2000/svg">
 <defs>
  <linearGradient gradientUnits="objectBoundingBox" x1="1" y1="-0.0183441" x2="1" id="linear_12" y2="1">
   <stop offset="0" stop-color="#494949"/>
   <stop offset="1" stop-color="#000000"/>
  </linearGradient>
  <linearGradient gradientUnits="objectBoundingBox" x1="0.146915" y1="1.01745" x2="0.146915" id="linear_0" y2="0.104475">
   <stop offset="0" stop-color="#494949"/>
   <stop offset="1" stop-color="#000000"/>
  </linearGradient>
 </defs>
 <desc>Sets/displays a value to/from an address.</desc>
 <title>Editable Label</title>
 <metadata>
  <atv:parameter name="base" defaultvalue="" valuetype="address" desc="base" behavior="mandatory"/>
  <atv:parameter name="validation" defaultvalue="Number" valuetype="enum" desc="input mode" config="Number;Boolean;String;Password;Time" behavior="optional"/>
  <atv:parameter name="allowDirectInput" defaultvalue="Yes" valuetype="enum" desc="allow direct input" config="Yes;No" behavior="optional"/>
  <atv:parameter group="Number Format" name="unit" valuetype="trstring" desc="displayed unit" behavior="optional"/>
  <atv:parameter group="Number Format" name="sign" defaultvalue="false" valuetype="bool" desc="show sign" behavior="optional"/>
  <atv:parameter group="Number Format" name="leadingZeros" defaultvalue="0" valuetype="number" desc="leading zeros" behavior="mandatory"/>
  <atv:parameter group="Number Format" name="postDecimal" defaultvalue="0" valuetype="number" desc="post decimal positions" behavior="mandatory"/>
  <atv:parameter group="Number Format" name="decimalFraction" defaultvalue="" valuetype="number" desc="force decimal fraction position" behavior="optional"/>
  <atv:parameter group="Enum List Mode" name="enumList" defaultvalue="" valuetype="global" desc="enum list" behavior="optional"/>
  <atv:parameter group="Font" name="fontFamily" defaultvalue="Arial" valuetype="enum" substitute="$FONTFAMILY$" desc="family" config="Times New Roman=Times New Roman,Bodoni,Garamond,Minion Web,ITC Stone Serif,MS Georgia,Bitstream Cyberbit,serif;Arial=MS Trebuchet,ITC Avant Garde Gothic,MS Arial,MS Verdana,Univers,Futura,ITC Stone Sans,Gill Sans,Akzidenz Grotesk,Helvetica,sans-serif;Courier=Courier,MS Courier New,Prestige,Everson Mono,monospace;Zapf-Chancery=Caflisch Script,Adobe Poetica,Sanvito,Ex Ponto,Snell Roundhand,Zapf-Chancery,cursive;Alpha Geometrique=Alpha Geometrique,Critter,Cottonwood,FB Reactor,Studz,fantasy;OpenSans-Regular;OpenSans-ExtraBold;OpenSans-BoldItalic;OpenSans-Bold" behavior="optional"/>
  <atv:parameter group="Font" name="fontSize" defaultvalue="16" valuetype="enum" substitute="$FONTSIZE$" desc="size" config="6;7;8;9;10;11;12;14;16;18;20;22;24;26;28;36;48;72" behavior="optional"/>
  <atv:parameter group="Font" name="fontColor" defaultvalue="#ffffff" valuetype="color" substitute="$FONTCOLOR$" desc="color" behavior="optional"/>
  <atv:parameter group="Appearance" name="fill" defaultvalue="#3f434a" valuetype="color" substitute="$FILL$" desc="fill color" behavior="optional"/>
  <atv:parameter group="Appearance" name="fillNotEditable" defaultvalue="#ffffff" valuetype="color" desc="fill color not editable" behavior="optional"/>
  <atv:parameter group="Appearance" name="fillColorInactive" defaultvalue="#8c8c8c" valuetype="color" desc="fill color when inactive" behavior="optional"/>
  <atv:parameter group="Limits" name="limitLowLow" defaultvalue="off" valuetype="string" desc="limit low low (off=no limit)" behavior="optional"/>
  <atv:parameter group="Limits" name="limitLow" defaultvalue="off" valuetype="string" desc="limit low (off=no limit)" behavior="optional"/>
  <atv:parameter group="Limits" name="limitHigh" defaultvalue="off" valuetype="string" desc="limit high (off=no limit)" behavior="optional"/>
  <atv:parameter group="Limits" name="limitHighHigh" defaultvalue="off" valuetype="string" desc="limit high high (off=no limit)" behavior="optional"/>
  <atv:parameter group="Limits" name="limitLowLowFill" defaultvalue="#ff0000" valuetype="color" desc="limit low low color" behavior="optional"/>
  <atv:parameter group="Limits" name="limitLowFill" defaultvalue="#ffff00" valuetype="color" desc="limit low color" behavior="optional"/>
  <atv:parameter group="Limits" name="limitHighFill" defaultvalue="#ffff00" valuetype="color" desc="limit high color" behavior="optional"/>
  <atv:parameter group="Limits" name="limitHighHighFill" defaultvalue="#ff0000" valuetype="color" desc="limit high high color" behavior="mandatory"/>
  <atv:parameter group="Appearance" name="focusStrokeColor" defaultvalue="#3e4249" valuetype="color" desc="focus stroke color" behavior="mandatory"/>
  <atv:parameter group="Security" name="editable" defaultvalue="Yes" valuetype="enum" desc="editable" config="Yes;No" behavior="optional"/>
  <atv:parameter group="Options" name="password" defaultvalue="No" valuetype="enum" desc="password mode" config="Yes;No" behavior="hidden"/>
  <atv:parameter group="Options" name="outputNode" defaultvalue="" valuetype="address" desc="alternative output address" behavior="optional"/>
  <atv:parameter group="Limits" name="min" defaultvalue="off" valuetype="number" desc="minimum" behavior="optional"/>
  <atv:parameter group="Limits" name="max" defaultvalue="off" valuetype="number" desc="maximum" behavior="optional"/>
  <atv:parameter group="Limits" name="nodeMin" defaultvalue="" valuetype="address" desc="address for minimum" behavior="optional"/>
  <atv:parameter group="Limits" name="nodeMax" defaultvalue="" valuetype="address" desc="address for maximum" behavior="optional"/>
  <atv:parameter group="Limits" name="nodeLowLow" defaultvalue="" valuetype="display" desc="address for limit low low" behavior="optional"/>
  <atv:parameter group="Limits" name="nodeLow" defaultvalue="" valuetype="address" desc="address for limit low" behavior="mandatory"/>
  <atv:parameter group="Limits" name="nodeHigh" defaultvalue="" valuetype="address" desc="address for limit high" behavior="optional"/>
  <atv:parameter group="Limits" name="nodeHighHigh" defaultvalue="" valuetype="address" desc="address for limit high high" behavior="optional"/>
  <atv:parameter group="Options" name="consistencyGroup" defaultvalue="" valuetype="string" desc="consistency group" behavior="optional"/>
  <atv:parameter group="Options" name="tabIndex" defaultvalue="" valuetype="number" desc="tab index" behavior="optional"/>
  <atv:parameter group="Options" name="tooltip" valuetype="trstring" desc="tooltip" behavior="optional"/>
  <atv:parameter group="Security" name="right" defaultvalue="" valuetype="address" desc="necessary right" config="SYSTEM.SECURITY.RIGHTS" behavior="optional"/>
  <atv:parameter group="Security" name="activeNode" defaultvalue="" valuetype="address" desc="activation address" behavior="optional"/>
  <atv:parameter group="Security" name="activeValue" defaultvalue="off" valuetype="string" desc="activation value" behavior="optional"/>
  <atv:parameter group="Options" name="selectTextOnFocus" defaultvalue="false" valuetype="bool" desc="select text on focus" behavior="optional"/>
  <atv:parameter group="Appearance" name="editingBackgroundColor" defaultvalue="#3f434a" valuetype="color" substitute="" desc="editing background color" behavior="optional"/>
  <atv:parameter group="Font" name="editingFontFamily" defaultvalue="Arial" valuetype="enum" desc="editing font family" config="Times New Roman=Times New Roman,Bodoni,Garamond,Minion Web,ITC Stone Serif,MS Georgia,Bitstream Cyberbit,serif;Arial=MS Trebuchet,ITC Avant Garde Gothic,MS Arial,MS Verdana,Univers,Futura,ITC Stone Sans,Gill Sans,Akzidenz Grotesk,Helvetica,sans-serif;Courier=Courier,MS Courier New,Prestige,Everson Mono,monospace;Zapf-Chancery=Caflisch Script,Adobe Poetica,Sanvito,Ex Ponto,Snell Roundhand,Zapf-Chancery,cursive;Alpha Geometrique=Alpha Geometrique,Critter,Cottonwood,FB Reactor,Studz,fantasy;OpenSans-Regular;OpenSans-ExtraBold;OpenSans-BoldItalic;OpenSans-Bold" behavior="optional"/>
  <atv:parameter group="Appearance" name="editingBorderColor" defaultvalue="#E3D700" valuetype="color" substitute="" desc="editing border color" behavior="optional"/>
  <atv:parameter name="controlTextColor" defaultvalue="#FFFFFF" valuetype="color" desc="control text color" behavior="optional"/>
  <atv:parameter name="controlEditingBackgroundColor" defaultvalue="#000000" valuetype="color" desc="control editing background color" behavior="optional"/>
  <atv:parameter name="controlTintColor" defaultvalue="#E3D700" valuetype="color" desc="control tint color" behavior="optional"/>
  <atv:parameter name="controlActiveBackgroundColor" defaultvalue="#000000" valuetype="color" desc="control active background color" behavior="optional"/>
  <atv:parameter name="controlBackgroundColor" defaultvalue="#3f434a" valuetype="color" desc="control background color" behavior="optional"/>
  <atv:gridconfig height="2" width="2" gridstyle="lines" enabled="true"/>
  <atv:snapconfig height="1" width="1" enabled="true"/>
 </metadata>
 <g atv:refpy="0" atv:refpx="0" id="input_element"/>
 <rect atv:bindbr="1,1" atv:refpy="31" ry="6" atv:refpx="80.4297" rx="6" height="46.5" width="152.326" stroke-width="3" atv:bindtl="0,0" fill="none" y="7.75" id="blinking_frame" x="4.267" stroke="none"/>
 <rect atv:bindbr="1,1" atv:refpy="15" ry="0" atv:refpx="39.5" rx="0" height="30" width="79" stroke-linecap="butt" stroke-width="1" atv:bindtl="0,0" fill="$FILL$" y="0" id="input_bg" x="0" stroke="#3f434a"/>
 <text atv:bindbr="0.5,0.5" atv:refpy="7" ry="4" atv:refpx="40" rx="4" atv:bindtl="0.5,0.5" fill="$FONTCOLOR$" font-size="$FONTSIZE$" text-anchor="middle" font-family="$FONTFAMILY$" y="21.5" id="input_label" x="40">T{value}</text>
 <foreignObject height="31" width="80" y="0" id="clickareaFO" x="0">
  <div xmlns="http://www.w3.org/1999/xhtml" id="div_clickarea" style="width:100%;height:100%;opacity:0;filter:alpha(opacity=0);background-color:red"/>
 </foreignObject>
 <style type="text/css"><![CDATA[	
@font-face {
	font-family: 'OpenSans-Regular';
	src: url("../../Font/OpenSans-Regular.ttf") format("truetype")
}
@font-face {
	font-family: 'OpenSans-ExtraBold';
	src: url("../../Font/OpenSans-ExtraBold.ttf") format("truetype")
}
@font-face {
	font-family: 'OpenSans-BoldItalic';
	src: url("../../Font/OpenSans-BoldItalic.ttf") format("truetype")
}
@font-face {
	font-family: 'OpenSans-Bold';
	src: url("../../Font/OpenSans-Bold.ttf") format("truetype")
}
]]></style>
 <script type="text/ecmascript"><![CDATA[var fontFamily = webMI.query["fontFamily"];
var controlTextColor = webMI.query["controlTextColor"];
var controlEditingBackgroundColor = webMI.query["controlEditingBackgroundColor"];
var controlTintColor = webMI.query["controlTintColor"];
var controlActiveBackgroundColor = webMI.query["controlActiveBackgroundColor"];
var controlBackgroundColor = webMI.query["controlBackgroundColor"];

var inputMode = webMI.query["validation"];
var inputFO = webMI.dom.createElement("http://www.w3.org/1999/xhtml", "input");
var isPasswordMode = (inputMode == "Password" || webMI.query["password"] == "Yes");
inputFO.type = isPasswordMode ? "password" : "text";
inputFO.id = "html_input";
inputFO.style.width = "100%";
inputFO.style.height = "100%";
inputFO.style.border = "1px solid yellow";
inputFO.style.outline = 'none';
inputFO.style.borderRadius = '4px';
inputFO.style.padding = "0px";
inputFO.style.boxSizing = 'border-box';
inputFO.style.textAlign = "center";
inputFO.style.color = controlTextColor;
inputFO.style.fontFamily = fontFamily;
inputFO.style.fontWeight = 'bold';
inputFO.style.fontSize = parseFloat(webMI.query["fontSize"])*0.0820625+"em";
inputFO.style.backgroundColor = controlEditingBackgroundColor;
inputFO.style.fontFamily = fontFamily;
var foreignObject = null;
var createdForeignObject = false;
var data = {};
var security = {};
var initialized = false;
var value = null;
var nodeToSubscribe = (webMI.query["outputNode"] != "") ? webMI.query["outputNode"] : webMI.query["base"];
var decimalFraction = parseInt(webMI.query["decimalFraction"], 10);
var tabHandler = webMI.callExtension("SYSTEM.LIBRARY.ATVISE.QUICKDYNAMICS.Tab Handler");
var consistencyHandler = webMI.callExtension("SYSTEM.LIBRARY.ATVISE.QUICKDYNAMICS.Consistency Handler");
var consistencyGroup = webMI.query["consistencyGroup"];
var preventFirstConsistencyRead = true;
var storedEvent = {"keyCode": null, "shiftKey": false};
var backgroundColor = webMI.query["fill"];

webMI.addOnload(function(e) {
	var remaining = 8;
	data = {
		"min":			{"value":null, "address": webMI.query["nodeMin"], "paramValue": webMI.query["min"]},
		"max":			{"value":null, "address": webMI.query["nodeMax"], "paramValue": webMI.query["max"]},
		"limitLowLow":	{"value":null, "address": webMI.query["nodeLowLow"], "paramValue": webMI.query["limitLowLow"]},
		"limitLow":		{"value":null, "address": webMI.query["nodeLow"], "paramValue": webMI.query["limitLow"]},
		"limitHigh":	{"value":null, "address": webMI.query["nodeHigh"], "paramValue": webMI.query["limitHigh"]},
		"limitHighHigh":{"value":null, "address": webMI.query["nodeHighHigh"], "paramValue": webMI.query["limitHighHigh"]},
		"activeNode":	{"value":null, "address": webMI.query["activeNode"], "paramValue": ""},
		"activeValue":	{"value":null, "address": "", "paramValue": webMI.query["activeValue"]},
		"base":			{"value":null, "address": webMI.query["base"], "paramValue": ""}
	};

	function initVariables(value, address, id) {
		if(id == "base" && consistencyGroup != "" && address != "") {
			webMI.data.read(address, function(e) {
				data[id]["value"] = e.value;
			});
			consistencyHandler.register(consistencyGroup, address, handleInput);
			reduceRemaining();
		} else if (address != "") {
			webMI.data.subscribe(address, function(e) {
				data[id]["value"] = e.value;
				reduceRemaining();
			});
		} else if (!isNaN(parseFloat(value))) {
			data[id]["value"] = parseFloat(value);
			reduceRemaining();
		} else if (typeof value == "string" && value != "off") {
			data[id]["value"] = value;
			reduceRemaining();
		} else
			reduceRemaining();

		function reduceRemaining() {
			if(!initialized)
				initialized = (--remaining == 0);
			else
				handleInput();
		}
	}

	for(var i in data)
		initVariables(data[i]["paramValue"], data[i]["address"], i);

	var doc = document.getElementById("svg_input").ownerDocument;
	tabHandler.register(webMI.query["tabIndex"],keyHandler,doc);

	if (webMI.query["tooltip"] != undefined)
		webMI.callExtension("SYSTEM.LIBRARY.ATVISE.QUICKDYNAMICS.Tooltip", {"auto":"true", "id":"clickareaFO", "text":webMI.query["tooltip"]});
});

function setColorization() {
	function setBackground(color) {
		webMI.gfx.setFill("input_bg", color);
		webMI.gfx.setStroke("input_bg", color);
		inputFO.style.color = controlTextColor;
		inputFO.style.backgroundColor = controlActiveBackgroundColor;
		inputFO.style.borderColor = controlTintColor;
		webMI.gfx.setFill("input_label", controlTextColor);
	}

	if(data["limitLowLow"]["value"] != null && value <= data["limitLowLow"]["value"])
		setBackground(webMI.query["limitLowLowFill"]);
	else if(data["limitLow"]["value"] != null && value <= data["limitLow"]["value"])
		setBackground(webMI.query["limitLowFill"]);
	else if(data["limitHighHigh"]["value"] != null && value >= data["limitHighHigh"]["value"])
		setBackground(webMI.query["limitHighHighFill"]);
	else if(data["limitHigh"]["value"] != null && value >= data["limitHigh"]["value"])
		setBackground(webMI.query["limitHighFill"]);
	else if(!security["hasRight"] || !security["activateInput"] || !security["activated"])
		setBackground(webMI.query["fillColorInactive"]);
	else if(security["outputModeOnly"])
		setBackground(webMI.query["fillNotEditable"]);
	else
		setBackground(controlBackgroundColor);
}

function handleInput(consistencyValue){
	if(consistencyGroup != "" && preventFirstConsistencyRead) {
		preventFirstConsistencyRead = false;
		return;
	}

	if(consistencyValue && consistencyGroup != "")
		consistencyHandler.set(consistencyGroup, data["base"]["address"], consistencyValue);
	
	value = (data["base"] && consistencyValue == undefined) ? data["base"]["value"] : consistencyValue;

	var formattedOutput = null;
	var enumList = webMI.query["enumList"];

	if (isPasswordMode)
		formattedOutput = "*** T{Password} ***";
	else if(enumList != "") {
		formattedOutput = (enumList[value] != undefined) ? enumList[value].value : value + " not in enum list";
		value = (enumList[value] != undefined) ? enumList[value].value : value;
	} else if(inputMode == "Number") {
		var leadingZeros = parseInt(webMI.query["leadingZeros"], 10);
		var postDecimal = parseInt(webMI.query["postDecimal"], 10);
		var sign = webMI.query["sign"] == "true";
		var unit = webMI.query["unit"];
		var fieldWidth = 0;
		formattedOutput = (value != null) ? value : "";

		if(!isNaN(decimalFraction) && decimalFraction > 0)
			formattedOutput = formattedOutput / Math.pow(10, decimalFraction);

		if(!isNaN(leadingZeros) && leadingZeros > 0)
			fieldWidth += leadingZeros;

		if(!isNaN(postDecimal) && postDecimal > 0) {
			if(postDecimal > 9)
				postDecimal = 9;
			fieldWidth += (postDecimal + 1);
		}

		if(!isNaN(leadingZeros) && !isNaN(postDecimal)) {
			var formatString = ((sign) ? "%+" : "%") + "0" + fieldWidth + "." + postDecimal + "f";
			formattedOutput = webMI.sprintf(formatString, formattedOutput);
		}

		value = formattedOutput;

		if(unit != undefined)
			formattedOutput = formattedOutput + " " + unit;
	}
	else if (inputMode == 'Time') {
		var b = webMI.query.base || new Date();

		if (consistencyValue) {
			for (var type in consistencyValue) {
				b['set' + type](consistencyValue[type]);
			}
		}
		value = b.valueOf();

		function format(number, places) {
			places = places || 2;
			return webMI.sprintf("%0" + places + "d", number);
		}

		formattedOutput = b.getHours() + ':' + format(b.getMinutes());
		if (b.getSeconds() !== 0 || b.getMilliseconds() !== 0) formattedOutput += ':' + format(b.getSeconds());
		if (b.getMilliseconds() !== 0) formattedOutput += '.' + format(b.getMilliseconds(), 3);
	}

	webMI.trigger.fire("valuechanged", (value == null) ? "" : value, "");
	webMI.gfx.setText("input_label", (formattedOutput != null) ? formattedOutput : value);

	security = {
		"outputModeOnly": (webMI.query["editable"] == "No"),
		"activateInput": (data["activeValue"]["value"] == null || data["activeNode"]["value"] == null) || data["activeValue"]["value"] == String(data["activeNode"]["value"]),
		"hasRight": true,
		"activated": (typeof security["activated"] === "boolean") ? security["activated"] : true
	};

	var requiredRight = webMI.query["right"];

	if (requiredRight != "") {
		if (requiredRight.search(/SYSTEM\.SECURITY\.RIGHTS\./) != -1)
			requiredRight = requiredRight.substring(23,requiredRight.length); //remove "prefix" SYSTEM.SECURITY.RIGHTS.

		webMI.addEvent(webMI.data, "clientvariableschange", function(e) {
			security["hasRight"] = webMI.hasRight(requiredRight);
			if(!security["hasRight"])
				switchToOutputMode();
			setColorization();
		});
	}

	if(!security["activateInput"])
		switchToOutputMode();

	if(security["outputModeOnly"])
		webMI.gfx.setVisible("clickareaFO", false);

	if(inputMode == "Number")
		value = parseFloat(value);

	setColorization();
}

var isInInputMode = false;
function switchToOutputMode() {
	webMI.gfx.setVisible("svg_input", null);
	webMI.gfx.setVisible(foreignObject, false);
	isInInputMode = true;
}

function switchToInputMode(){
	if(security["hasRight"] && !security["outputModeOnly"] && security["activateInput"] && security["activated"]) {

		var directKeyboardMode = webMI.query["allowDirectInput"] == "Yes";
		var useSVGKeyboard = webMI.callExtension("SYSTEM.LIBRARY.ATVISE.QUICKDYNAMICS.Configuration", {"action":"existsIndexParameter", "parameterName":"useSVGKeyboard"});
		if(useSVGKeyboard == "true")
			directKeyboardMode = false;

		function setFocus() {
			inputFO.focus();
			if(webMI.query["selectTextOnFocus"] == "true")
				inputFO.select();
		}

		if(directKeyboardMode) {
			tabHandler.setAcceptKeys(false);
			inputFO.value = inputMode == 'Time' ? webMI.gfx.getText('input_label') : value;
			webMI.gfx.setVisible("svg_input", false);
			if(!createdForeignObject) {
				var textboxGroup = document.getElementById("input_element");
				foreignObject = webMI.gfx.addForeignObject({x:0, y:0, width:80, height:31, id:"input_fo", childNodes: [inputFO]}, textboxGroup);
				createdForeignObject = true;
				setFocus();
			 } else {
				webMI.gfx.setVisible(foreignObject, null);
				setFocus();
			}
		} else {
			function getDisplayParameters(){
				var communicationID = new Date().getTime().toString();
				webMI.trigger.connect(communicationID, function(e) {
					checkInput(e.value);
				});

				var passObj = {};
				for (var i in webMI.query)
					passObj[i] = webMI.query[i];
				passObj["minValue"] = data["min"]["value"];
				passObj["maxValue"] = data["max"]["value"];
				if (nodeToSubscribe != "" && consistencyGroup == "")
					passObj["target"] = nodeToSubscribe;
				if (nodeToSubscribe == "" || consistencyGroup != "")
					passObj["trigger"] = communicationID;
				if (isPasswordMode)
					passObj["password"] = "Yes";
				return passObj;
			}

			var keyboard = null;
			var size = (inputMode != undefined && inputMode == "Number") ? {w: 438, h: 378} : {w: 550, h: 250};

			if (inputMode != undefined && inputMode == "Number")
				keyboard = "SYSTEM.LIBRARY.ATVISE.OBJECTDISPLAYS.Standard.keyboard.number_keyboard";
			else
				keyboard = "SYSTEM.LIBRARY.ATVISE.OBJECTDISPLAYS.Standard.keyboard.keyboard";

			var keyboardParam = getDisplayParameters();
			webMI.display.openWindow({display:keyboard,extern:false,height:size.h,menubar:false,modal:true,movable:true,resizable:false,scrollbars:false,status:false,title:"T{Keyboard}",toolbar:false,width:size.w,query:keyboardParam});
		}

		isInInputMode = true;
	}
}

function keyHandler(keyTH,param2){
	if (keyTH == "focus")
		webMI.gfx.setStroke("input_bg", controlTintColor);
	else if (keyTH == "blur")
		webMI.gfx.setStroke("input_bg", controlBackgroundColor);
	else if (keyTH == "apply")
		switchToInputMode();
	else if (keyTH == "isActive")
		return (security["hasRight"] && !security["outputModeOnly"] && security["activateInput"] && security["activated"] && param2(document.getElementById("svg_input").parentNode));
}

webMI.addEvent(('ontouchend' in window) ? this : 'clickareaFO', ('ontouchend' in window) ? 'touchend' : 'click', function(e) {
	if (!e.changedTouches || e.changedTouches[0].target.parentNode == document.getElementById('svg_input')) {
		tabHandler.setCurrentIndex(keyHandler);
		switchToInputMode();
	}
});

webMI.addEvent('clickareaFO', 'click', function(e) {
	if (!e.changedTouches || e.changedTouches.length == 0 || e.changedTouches[0].target.parentNode == document.getElementById('svg_input')) {
		tabHandler.setCurrentIndex(keyHandler);
		switchToInputMode();
	}
});

function stopPropagation(event) {
	if (event.altKey){
		if (event.stopPropagation)
			event.stopPropagation();
		else
			event.cancelBubble = true;
	}
}

webMI.addEvent(inputFO, "keyup", stopPropagation);
webMI.addEvent(inputFO, "keydown", function(e) {
	var keyCode = e.keyCode;
	if (/MSIE/.test(navigator.userAgent)){
		storedEvent["keyCode"] = e.keyCode;
		storedEvent["shiftKey"] = e.shiftKey;
	}
	if(keyCode == "13" || keyCode == "9") {
		inputFO.blur();
		if (keyCode == "13") tabHandler.setAcceptKeysPrevent(true);
	} else if(keyCode == "27"){
		storedEvent["keyCode"] = "27";
		tabHandler.setAcceptKeysPrevent(true);
		inputFO.blur();
	}

	stopPropagation(e);
});

inputFO.onblur = function() {
	switchToOutputMode();
	tabHandler.setAcceptKeys(true);

	if (storedEvent["keyCode"] != null){
		if (storedEvent["shiftKey"] && storedEvent["keyCode"] == "9")
			tabHandler.prevTab();
		else if (storedEvent["keyCode"] == "9")
			tabHandler.nextTab();
	}

	if (storedEvent["keyCode"] != "27"){
		setTimeout(function(){
			checkInput(inputFO.value);
		},0);
	}

	storedEvent["keyCode"] = null;
};

function checkInput(tempValue) {
	var tempValue = String(tempValue);
	var regexps = {
		"Boolean":"(true|false|0|1)",
		"Number":"[+-]*[0-9]+(\.[0-9]+)?",
		"String":".*",
		"Password":".*",
		"Time":"[0-9]+\:[0-9]{2}(\:[0-9]{2}(\.[0-9]{1,3})?)?"
	};
	if(new RegExp("^" + regexps[inputMode] + "$", "i").test(tempValue)) {
		if(inputMode == "Boolean")
			tempValue = (tempValue.toLowerCase() == "true" || tempValue == "1") ? true : false;
		else if(inputMode == "Number")
			tempValue = tempValue = parseFloat(tempValue.replace(",","."));
	} else {
		console.warn("Please enter a valid format according to the selected input mode.");
		return;
	}

	if(inputMode == "Number") {
		if(data["min"] && data["min"]["value"] != null && tempValue < data["min"]["value"]) {
			alert("T{Value too low}");
			return;
		} else if(data["max"] && data["max"]["value"] != null && tempValue > data["max"]["value"]) {
			alert("T{Value too high}");
			return;
		}

		if(!isNaN(decimalFraction) && decimalFraction > 0)
			tempValue = tempValue * Math.pow(10, decimalFraction);

		writeValue(tempValue);
	} else if(inputMode == "String" || inputMode == "Boolean" || inputMode == "Password")
		writeValue(tempValue);
	else if (inputMode == 'Time') {
		var parts = tempValue.replace('.', ':').split(':'),
			values = { Hours: 0, Minutes: 0, Seconds: 0, Milliseconds: 0 };

		if (parts.length < 2) { console.warn('Got invalid input "' + value + '"'); }
		else {
			var i = 0;
			for (var type in values) {
				values[type] = parseInt(parts[i] || 0);
				i++;
			}

			writeValue(values);
		}
	}

	function writeValue(tempValue) {
		if(consistencyGroup == "" && nodeToSubscribe != ""){
			webMI.data.write(nodeToSubscribe, tempValue);
			webMI.trigger.fire("com.atvise.outputvaluechanged", tempValue, "");
		}
		else handleInput(tempValue);

	}
}

webMI.trigger.connect("setValue", function(e) {
	checkInput(e.value);
});

webMI.trigger.connect("com.atvise.setActive",function(e){
	security["activated"] = e.value;

	setColorization();
	if (!isInInputMode) switchToOutputMode();
});

webMI.trigger.connect("com.atvise.setBlinking", function(e){
	if (e.value == "none"){
		webMI.gfx.setStroke("blinking_frame", e.value);
		webMI.gfx.setVisible("blinking_frame", null);
	} else {
		webMI.gfx.setStroke("blinking_frame", e.value);
		webMI.gfx.setVisible("blinking_frame",{0:true,2:false,4:true,6:false,8:true,10:false});
	}
});

webMI.trigger.connect("com.atvise.setBackground", function(e){
	backgroundColor = (e.value == "") ? webMI.query["editingBackgroundColor"] : e.value;
	setColorization();
});]]></script>
</svg>
